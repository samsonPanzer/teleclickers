<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fidget Spinner</title>
<style>
 #spinnerCanvas{
    display: block;
    margin: auto;
    background-color: transparent;
    position: absolute;
  }
</style>
</head>
<body>
    <h1 id="speed"></h1>
<canvas id="spinnerCanvas"></canvas>

<script>
  const canvas = document.getElementById('spinnerCanvas');
  canvas.style.width = window.innerWidth + "px"
  canvas.style.height = window.innerWidth + "px"
  canvas.width = window.innerWidth 
  canvas.height = window.innerWidth 
  const spinctx = canvas.getContext('2d');
  let angle = 0;
  const spincenterX = canvas.width / 2;
  const spincenterY = canvas.height / 2;
  const spinnerRadius = canvas.width/2
  let lastX = spincenterX;
  let lastY = spincenterY;
  let spinningSpeed = 0;
  let isInteracting = false;
  let friction = 0.98
  const spinnerImage = new Image();
  spinnerImage.src = 'https://raw.githubusercontent.com/samsonPanzer/teleclickers/main/images/fidget.png'; // Replace with your image URL
  spinnerImage.onload = animate; // Start the animation after the image loads

  function drawSpinner(spinctx, angle) {
    spinctx.clearRect(0, 0, canvas.width, canvas.height); // Clear canvas
    spinctx.save();
    spinctx.translate(spincenterX, spincenterY); // Move to the spincenter of the canvas
    spinctx.rotate(angle); // Rotate the canvas
    // Draw the image spincentered on the canvas
    spinctx.drawImage(spinnerImage, -spinnerImage.width / 2, -spinnerImage.height / 2);
    spinctx.restore();
  }

  function animate() {
    angle += spinningSpeed;
    drawSpinner(spinctx, angle);
    // Slow down the spinner over time
    spinningSpeed *= friction;
    document.getElementById("speed").innerText = Math.abs(spinningSpeed).toFixed(3)
    requestAnimationFrame(animate);
  }

  function getAngle(cx, cy, ex, ey) {
    const dy = ey - cy;
    const dx = ex - cx;
    const theta = Math.atan2(dy, dx);
    return theta;
  }

  function startInteraction(x, y) {
    isInteracting = true;
    lastX = x;
    lastY = y;
  }

  function moveInteraction(x, y) {
    if (isInteracting) {
      const newAngle = getAngle(spincenterX, spincenterY, x, y);
      const oldAngle = getAngle(spincenterX, spincenterY, lastX, lastY);
      const angleDifference = newAngle - oldAngle;

      // Use the angle difference to set the spinning speed
      spinningSpeed = angleDifference;
      lastX = x;
      lastY = y;
    }
  }

  function endInteraction() {
    isInteracting = false;
  }

  function getTouchPos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: e.touches[0].clientX - rect.left,
      y: e.touches[0].clientY - rect.top
    };
  }

  // canvas.addEventListener('mousedown', function(e) {
  //   const rect = canvas.getBoundingClientRect();
  //   startInteraction(e.clientX - rect.left, e.clientY - rect.top);
  // });

  // canvas.addEventListener('mousemove', function(e) {
  //   if (isInteracting) {
  //     const rect = canvas.getBoundingClientRect();
  //     moveInteraction(e.clientX - rect.left, e.clientY - rect.top);
  //   }
  // });

  // canvas.addEventListener('mouseup', endInteraction);
  // canvas.addEventListener('mouseleave', endInteraction);
  var centerX, centerY, radius = window.innerWidth / 10; // Circle properties
  // Touch event listeners
  canvas.addEventListener('touchstart', function(e) {

    // if (isInsideCircle(touch.clientX, touch.clientY)) {
    //   return
    // }

    e.preventDefault(); // Prevent scrolling when touching the canvas
    const touchPos = getTouchPos(e);
    startInteraction(touchPos.x, touchPos.y);
  });

  canvas.addEventListener('touchmove', function(e) {
    // if (isInsideCircle(touch.clientX, touch.clientY)) {
    //   return
    // }
    e.preventDefault(); // Prevent scrolling when touching the canvas
    const touchPos = getTouchPos(e);
    moveInteraction(touchPos.x, touchPos.y);
  });

  canvas.addEventListener('touchend', endInteraction);
  canvas.addEventListener('touchcancel', endInteraction);

// Function to check if the touch point is inside the circle
function isInsideCircle(touchX, touchY) {
    var dx = touchX - centerX;
    var dy = touchY - (circlePaddingY+centerY);
    return dx * dx + dy * dy <= radius * radius;
}


  // Start the animation loop
  //animate();
</script>
</body>
</html>
